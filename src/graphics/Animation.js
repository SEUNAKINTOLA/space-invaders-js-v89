/**
 * @fileoverview Sprite Animation System
 * Handles sprite loading, management, and animation with performance optimization
 * and memory management.
 * 
 * @module graphics/Animation
 * @author Generated by AI Assistant
 * @version 1.0.0
 */

// Constants for animation states and configuration
const ANIMATION_STATES = {
    PLAYING: 'playing',
    PAUSED: 'paused',
    STOPPED: 'stopped'
};

const DEFAULT_CONFIG = {
    frameRate: 60,
    loop: false,
    autoPlay: false,
    cacheSize: 50
};

/**
 * Represents an animation frame with its metadata
 * @typedef {Object} Frame
 * @property {number} duration - Duration in milliseconds
 * @property {number} x - X coordinate in sprite sheet
 * @property {number} y - Y coordinate in sprite sheet
 * @property {number} width - Frame width
 * @property {number} height - Frame height
 */

/**
 * Animation class for managing sprite animations
 * @class Animation
 */
export class Animation {
    #frames;
    #currentFrame;
    #state;
    #lastFrameTime;
    #config;
    #frameCache;
    #eventListeners;

    /**
     * Creates a new Animation instance
     * @param {Object} options - Animation configuration options
     * @param {Frame[]} options.frames - Array of animation frames
     * @param {Object} [options.config] - Optional configuration overrides
     * @throws {Error} If invalid options are provided
     */
    constructor(options) {
        this.#validateOptions(options);
        
        this.#frames = options.frames;
        this.#currentFrame = 0;
        this.#state = ANIMATION_STATES.STOPPED;
        this.#lastFrameTime = 0;
        this.#config = { ...DEFAULT_CONFIG, ...(options.config || {}) };
        this.#frameCache = new Map();
        this.#eventListeners = new Map();

        // Initialize the animation
        this.#initialize();
    }

    /**
     * Validates constructor options
     * @private
     * @param {Object} options - Options to validate
     * @throws {Error} If options are invalid
     */
    #validateOptions(options) {
        if (!options || !Array.isArray(options.frames) || options.frames.length === 0) {
            throw new Error('Animation requires valid frames array');
        }

        options.frames.forEach((frame, index) => {
            if (!frame.duration || !frame.width || !frame.height) {
                throw new Error(`Invalid frame data at index ${index}`);
            }
        });
    }

    /**
     * Initializes the animation system
     * @private
     */
    #initialize() {
        if (this.#config.autoPlay) {
            this.play();
        }
    }

    /**
     * Starts playing the animation
     * @public
     * @returns {void}
     */
    play() {
        if (this.#state === ANIMATION_STATES.PLAYING) return;

        this.#state = ANIMATION_STATES.PLAYING;
        this.#lastFrameTime = performance.now();
        this.#animate();
        this.#emit('play');
    }

    /**
     * Pauses the animation
     * @public
     * @returns {void}
     */
    pause() {
        if (this.#state !== ANIMATION_STATES.PLAYING) return;

        this.#state = ANIMATION_STATES.PAUSED;
        this.#emit('pause');
    }

    /**
     * Stops the animation and resets to first frame
     * @public
     * @returns {void}
     */
    stop() {
        this.#state = ANIMATION_STATES.STOPPED;
        this.#currentFrame = 0;
        this.#emit('stop');
    }

    /**
     * Main animation loop
     * @private
     */
    #animate() {
        if (this.#state !== ANIMATION_STATES.PLAYING) return;

        const currentTime = performance.now();
        const deltaTime = currentTime - this.#lastFrameTime;

        if (deltaTime >= this.#frames[this.#currentFrame].duration) {
            this.#updateFrame();
            this.#lastFrameTime = currentTime;
        }

        requestAnimationFrame(() => this.#animate());
    }

    /**
     * Updates the current frame
     * @private
     */
    #updateFrame() {
        this.#currentFrame++;

        if (this.#currentFrame >= this.#frames.length) {
            if (this.#config.loop) {
                this.#currentFrame = 0;
                this.#emit('loop');
            } else {
                this.stop();
                this.#emit('complete');
            }
        }
    }

    /**
     * Gets the current frame data
     * @public
     * @returns {Frame} Current frame data
     */
    getCurrentFrame() {
        return this.#frames[this.#currentFrame];
    }

    /**
     * Adds an event listener
     * @public
     * @param {string} event - Event name
     * @param {Function} callback - Event callback
     * @returns {void}
     */
    addEventListener(event, callback) {
        if (!this.#eventListeners.has(event)) {
            this.#eventListeners.set(event, new Set());
        }
        this.#eventListeners.get(event).add(callback);
    }

    /**
     * Removes an event listener
     * @public
     * @param {string} event - Event name
     * @param {Function} callback - Event callback
     * @returns {void}
     */
    removeEventListener(event, callback) {
        if (this.#eventListeners.has(event)) {
            this.#eventListeners.get(event).delete(callback);
        }
    }

    /**
     * Emits an event
     * @private
     * @param {string} event - Event to emit
     */
    #emit(event) {
        if (this.#eventListeners.has(event)) {
            for (const callback of this.#eventListeners.get(event)) {
                try {
                    callback();
                } catch (error) {
                    console.error(`Error in animation event listener: ${error}`);
                }
            }
        }
    }

    /**
     * Cleans up animation resources
     * @public
     * @returns {void}
     */
    dispose() {
        this.stop();
        this.#frameCache.clear();
        this.#eventListeners.clear();
    }
}

// Export animation states as frozen object
export const AnimationStates = Object.freeze(ANIMATION_STATES);